# -*- coding: utf-8 -*-
"""PyTorchAttempt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NMueNoEXq8baoraAqPyoXBgvXqgbS2o5
"""

import os, random, cv2, glob, itertools, shutil
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from PIL import Image
import torch
import torch.nn as nn
import torch.optim as optim
import torch.utils.data as data
import torchvision.datasets as dset
from torch.autograd import Variable
import torchvision
from torchvision import datasets, transforms, utils
from tqdm.notebook import tqdm
import warnings
warnings.filterwarnings('ignore')

from tensorflow.keras.preprocessing.image import load_img

import pandas as pd
from sklearn.model_selection import train_test_split
from tqdm import tqdm
import numpy as np
# torch imports
import torch
from torch import nn
from torch.utils.data import DataLoader
from torchvision import transforms
from torch.utils.data import Dataset
import torch.nn.functional as F

!unzip -uq "/content/drive/MyDrive/archive.zip" -d "/content"

class UTKDataset(Dataset):
    '''
        Inputs:
            dataFrame : Pandas dataFrame
            transform : The transform to apply to the dataset
    '''
    def __init__(self, dataframe, transform=None):
        # read in the transforms
        self.transform = transform
        
        # Use the dataFrame to get the pixel values
        data_holder = dataframe.pixels.apply(lambda x: np.array(x.split(" "),dtype=float))
        arr = np.stack(data_holder)
        arr = arr / 255.0
        arr = arr.astype('float32')
        arr = arr.reshape(arr.shape[0], 48, 48, 1)
        # reshape into 48x48x1
        self.data = arr
        
        # get the age, gender, and ethnicity label arrays
        self.age_label = np.array(dataframe.age[:])        # Note : Changed dataFrame.age to dataFrame.bins with most recent change
        self.gender_label = np.array(dataframe.gender[:])
        self.race_label = np.array(dataframe.ethnicity[:])
    
    # override the length function
    def __len__(self):
        return len(self.data)
    
    # override the getitem function
    def __getitem__(self, index):
        # load the data at index and apply transform
        data = self.data[index]
        data = self.transform(data)
        
        # load the labels into a list and convert to tensors
        labels = torch.tensor((self.age_label[index], self.gender_label[index], self.eth_label[index]))
        
        # return data labels
        return data, labels

BASE_DIR = '/content/UTKFace'
# labels - age, gender, ethnicity
image_paths = []
race_labels = []
gender_labels = []

from tqdm.notebook import tqdm
import os
for filename in tqdm(os.listdir(BASE_DIR)):
    image_path = os.path.join(BASE_DIR, filename)
    temp = filename.split('_')
    gender = int(temp[1])
    if isinstance(temp[1],int) == True:
      race = int(temp[2])
    else:
      race = 4
    image_paths.append(image_path)
    race_labels.append(race)
    gender_labels.append(gender)

#Visualize data by pandas
image_paths = pd.Series(list(image_paths), name = 'Images Path')
gender_labels = pd.Series(list(gender_labels), name = 'Genders')
race_labels = pd.Series(list(race_labels), name = 'Races')

dataframe = pd.concat([image_paths, gender_labels, race_labels], axis = 1)
dataframe

from tqdm import tqdm
from PIL import Image, ImageOps

def extract_features(images):
    features = []
    for image in tqdm(images):
        img = load_img(image, grayscale=False)
        img = img.resize((64, 64), Image.ANTIALIAS)
        img = np.array(img)
        features.append(img)
        
    features = np.array(features)
    # ignore this step if using RGB
    #features = features.reshape(len(features), 128, 128, 3)
    return features

X = extract_features(dataframe['Images Path'])
X = X/255.0 # normalize 

y_gender = np.array(dataframe['Genders'])
y_race = np.array(dataframe['Races'])

labelFrame = pd.read_csv('age_gender.csv')

# Construct age bins
age_bins = [0,10,15,20,25,30,40,50,60,120]
age_labels = [0, 1, 2, 3, 4, 5, 6, 7, 8]
labelFrame['bins'] = pd.cut(labelFrame.age, bins=age_bins, labels=age_labels)

# get the number of unique classes for each group
class_nums = {'age_num':len(labelFrame['bins'].unique()), 'eth_num':len(labelFrame['ethnicity'].unique()),
              'gen_num':len(labelFrame['gender'].unique())}

train_transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.49,), (0.23,))
])

datatrain = UTKDataset(labelFrame, transform=train_transform)
training_data = DataLoader(datatrain, batch_size=32, shuffle=True)

ngpu = 0

device = torch.device("cuda:0" if (torch.cuda.is_available() and ngpu > 0) else "cpu")

# custom weights initialization called on netG and netD
def weights_init(m):
    classname = m.__class__.__name__
    if classname.find('Conv') != -1:
        nn.init.normal_(m.weight.data, 0.0, 0.02)
    elif classname.find('BatchNorm') != -1:
        nn.init.normal_(m.weight.data, 1.0, 0.02)
        nn.init.constant_(m.bias.data, 0)

# Classifier code

class RaceClassifier(nn.Module):
  def __init__(self):
      super(RaceClassifier, self).__init__()
      self.main = nn.Sequential(
          nn.ConvTranspose2d(32,64,(3,3),bias=False),
          nn.MaxPool2d(2, stride=2),
          nn.BatchNorm2d(64),
          nn.ReLU(True),
          nn.ConvTranspose2d(64,128,(3,3),bias=False),
          nn.MaxPool2d(2, stride=2),
          nn.BatchNorm2d(64),
          nn.ReLU(True),
          nn.ConvTranspose2d(128,128,(3,3),bias=False),
          nn.MaxPool2d(2, stride=2),
          nn.BatchNorm2d(64),
          nn.ReLU(True),
          nn.ConvTranspose2d(128,128,(3,3),bias=False),
          nn.MaxPool2d(2, stride=2),
          nn.BatchNorm2d(64),
          nn.ReLU(True),
          nn.Flatten()
        )
    
  def forward(self, input):
        return self.main(input)

race_output = RaceClassifier().to(device)

race_output.apply(weights_init)

print(race_output)

class Discriminator(nn.Module):
  def __init__(self):
      super(Discriminator, self).__init__()
      self.main = nn.Sequential(
          nn.Linear(8,12),
          nn.ReLU(True),
          nn.Linear(8,1),
          nn.ReLU(True),
          nn.Linear(1,1),
          nn.Sigmoid()
          )
    
  def forward(self, input):
        return self.main(input)

class Generator(nn.Module):
  def __init__(self):
      super(Generator, self).__init__()
      self.main = nn.Sequential(
          nn.ConvTranspose2d(32,64,(3,3),bias=False),
          nn.MaxPool2d(2, stride=2),
          nn.ReLU(True),
          nn.ConvTranspose2d(64,128,(3,3),bias=False),
          nn.MaxPool2d(2, stride=2),
          nn.ReLU(True),
          nn.ConvTranspose2d(128,128,(3,3),bias=False),
          nn.MaxPool2d(2, stride=2),
          nn.ReLU(True),
          nn.ConvTranspose2d(128,128,(3,3),bias=False),
          nn.MaxPool2d(2, stride=2),
          nn.ReLU(True),
          nn.Flatten(),
          nn.Linear(128,128),
          nn.ReLU(True),
          nn.Dropout(0.3),
          nn.Linear(1,1),
          nn.Sigmoid()
        )
    
  def forward(self, input):
        return self.main(input)

d = Discriminator().to(device)
g = Generator().to(device)

d.apply(weights_init)
g.apply(weights_init)

generator_optimizer = torch.optim.Adam(g.parameters(), lr=0.001)
discriminator_optimizer = torch.optim.Adam(d.parameters(), lr=0.001)

def generator_loss(true_race, pred_race):
    entropy = tf.reduce_mean(-tf.reduce_sum(true_race * tf.log(pred_race), reduction_indices=[1]))
    return entropy

def discriminator_loss(true_gender, pred_gender, alpha):
    entropy = tf.reduce_mean(-tf.reduce_sum(true_gender * tf.log(pred_gender), reduction_indices=[1]))
    return entropy

def trainstep(X,y,gender):
  y = tf.convert_to_tensor(y, dtype=tf.float32)
  gender = tf.convert_to_tensor(gender, dtype=tf.float32)

  d = Discriminator().to(device)
  g = Generator().to(device)

  d.apply(weights_init)
  g.apply(weights_init)
  
  age, gen, race = y[:,0].to(device), y[:,1].to(device), y[:,2].to(device)
  X = X.to(device)
  predrace = g(X)
  truerace = y
  predgender = d(predrace)

  gen_loss = generator_loss(truerace,predrace)
  disc_loss = discriminator_loss(gen,predgender,0.1)
  
  return gen_loss, disc_loss

# Training 

# Lists
gloss = []
dloss = []

epochs = 2
itr = 0
batch_size = 32
n_train = len(X)

for epoch in range(epochs):